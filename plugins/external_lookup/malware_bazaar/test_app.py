from urllib import parse as ul

import pytest
import requests

from .app import app, CLASSIFICATION, TAG_MAPPING


def dquote(tag):
    """Double encode the tag."""
    return ul.quote(ul.quote(tag, safe=""), safe="")


@pytest.fixture()
def test_client():
    """generate a test client."""
    with app.test_client() as client:
        with app.app_context():
            app.config["TESTING"] = True
            yield client


@pytest.fixture()
def mock_lookup_exists(mocker):
    """Mock response for a hash that exists."""

    def _mock_lookup_exists(
        *,
        sha256_hash="7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754",
        sha1_hash="77543bde72105ae1a28cc71815d9ea89ea162052",
        md5_hash="c40aead7a31d14e05b2ee4a11849eced",
        imphash="f34d5f2d4577ed6d9ceec516c1f5a744",
        tlsh="T1AA15491232F50F49F8BE97F9562810918777BA9E513ED24C7D8D30DE4BA2B010A67B27",
        comment="Malspam distributing AZORult",
        delivery_method="email",
        archive_pw=None,
        reporter="abuse_ch",
        signature="AZORult",
        origin_country=None,
        file_name="file.exe",
        file_information=None,
        tags=None,
        yara_rules=None,
        intelligence={
            "clamav": [
                "SecuriteInfo.com.Trojan.InjectNET.14.27839.30.UNOFFICIAL",
            ],
        },
        vendor_intel={
            "CERT-PL_MWDB": {
                "detection": "azorult",
                "link": "https://mwdb.cert.pl/sample/7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754/",
            },
            "YOROI_YOMI": {"detection": "Malicious File", "score": "1.00"},
            "ReversingLabs": {
                "threat_name": "ByteCode-MSIL.Trojan.AgentTesla",
                "status": "MALICIOUS",
                "first_seen": "2020-10-19 05:14:13",
                "scanner_count": "28",
                "scanner_match": "23",
                "scanner_percent": "82.14",
            },
            "Spamhaus_HBL": [
                {
                    "detection": "malicious",
                    "link": "https://www.spamhaus.org/hbl/",
                }
            ],
        },
        additional_results=None,
    ):
        result_args = [
            "sha256_hash",
            "sha1_hash",
            "md5_hash",
            "imphash",
            "tlsh",
            "delivery_method",
            "tags",
            "file_name",
            "archive_pw",
            "origin_country",
            "comment",
            "reporter",
            "signature",
            "intelligence",
            "file_information",
            "yara_rules",
        ]
        hash_only = ["vendor_intel"]
        # create the default result
        kwargs = {k: v for k, v in locals().items() if k in result_args or (k in hash_only and v is not None)}

        # append additional results
        data = [kwargs]
        if additional_results is None:
            additional_results = []
        elif isinstance(additional_results, dict):
            additional_results = [additional_results]
        data.extend(additional_results)

        mock_response = mocker.MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "query_status": "ok",
            "data": data,
        }
        # setup mock response for a valid hash lookup
        mock_session = mocker.patch.object(requests, "Session", autospec=True)
        mock_session.return_value.post.return_value = mock_response
        return data

    return _mock_lookup_exists


def test_get_mappings(test_client, mocker):
    """Ensure tags are returned."""
    rsp = test_client.get("/tags/")
    assert rsp.status_code == 200
    data = rsp.json["api_response"]
    assert data == {tname: CLASSIFICATION for tname in sorted(TAG_MAPPING)}


def test_hash_found(test_client, mock_lookup_exists):
    """Validate respone for a hash that exists with no enrichment."""
    digest = "7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754"
    mock_lookup_exists(sha256_hash=digest)

    rsp = test_client.get(f"/details/sha256/{dquote(digest)}/", query_string={"nodata": True})
    expected = {
        "api_error_message": "",
        "api_response": [
            {
                "classification": "TLP:CLEAR",
                "link": f"https://bazaar.abuse.ch/browse.php?search=sha256%3A{digest}",
                "count": 1,
                "malicious": True,
                "confirmed": False,
                "description": "4 security vendors flagged this file as malicious. The file has been identified as: AZORult",
            }
        ],
        "api_status_code": 200,
    }

    assert rsp.status_code == 200
    assert rsp.json == expected


def test_hash_dne(test_client, mocker):
    """Validate respone for a hash that does not exists."""
    digest = "a" * 32
    mock_response = mocker.MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        "query_status": "hash_not_found",
    }

    # setup mock response for a valid hash lookup
    mock_session = mocker.patch.object(requests, "Session", autospec=True)
    mock_session.return_value.post.return_value = mock_response

    rsp = test_client.get(f"/details/md5/{dquote(digest)}/", query_string={"nodata": True})
    expected = {
        "api_error_message": "No results.",
        "api_response": None,
        "api_status_code": 404,
    }
    assert rsp.status_code == 404
    assert rsp.json == expected


def test_error_conditions(test_client, mocker):
    """Validate error handling."""

    # unknown error
    mock_response = mocker.MagicMock()
    mock_response.status_code = 400
    mock_response.text = "Some bad response"
    mock_session = mocker.patch.object(requests, "Session", autospec=True)
    mock_session.return_value.post.return_value = mock_response

    rsp = test_client.get(f"/details/md5/{dquote('a' * 32)}/", query_string={"nodata": True})
    expected = {
        "api_error_message": "Unknown error submitting data to upstream.",
        "api_response": "Some bad response",
        "api_status_code": 400,
    }
    assert rsp.status_code == 400
    assert rsp.json == expected

    # invalid hash
    rsp = test_client.get("/details/md5/abc}/")
    expected = {
        "api_error_message": "Invalid hash provided. Require md5, sha1 or sha256",
        "api_response": None,
        "api_status_code": 422,
    }
    assert rsp.status_code == 422
    assert rsp.json == expected

    # invalid tag name
    rsp = test_client.get("/details/abc/abc}/")
    assert rsp.status_code == 422
    assert rsp.json["api_error_message"].startswith("Tag name `abc` is invalid.")

    # Non-handled query_status
    mock_response = mocker.MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        "query_status": "no_hash_provided",
    }
    mock_session.return_value.post.return_value = mock_response

    rsp = test_client.get(f"/details/md5/{dquote('a' * 32)}/")
    expected = {
        "api_error_message": "no_hash_provided",
        "api_response": None,
        "api_status_code": 400,
    }
    assert rsp.status_code == 400
    assert rsp.json == expected


def test_imphash_found(test_client, mock_lookup_exists):
    """Validate respone for an imphash that exists."""
    imphash = "45d579faec0eaf279c0841b2233727cf"
    mock_lookup_exists(
        imphash=imphash,
        additional_results={
            "sha256_hash": "a" * 64,
            "signature": None,
            "intelligence": {
                "clamav": [
                    "SecuriteInfo.com.Trojan.InjectNET.14.27839.30.UNOFFICIAL",
                ],
            },
        },
    )

    rsp = test_client.get(f"/details/file.pe.imports.imphash/{dquote(imphash)}/", query_string={"nodata": True})
    expected = {
        "api_error_message": "",
        "api_response": [
            {
                "classification": "TLP:CLEAR",
                "count": 2,
                "link": f"https://bazaar.abuse.ch/browse.php?search=imphash%3A{imphash}",
                "malicious": True,
                "confirmed": False,
                "description": "2 malicious files were found. They were identified as: AZORult",
            }
        ],
        "api_status_code": 200,
    }

    assert rsp.status_code == 200
    assert rsp.json == expected


def test_hash_details(test_client, mock_lookup_exists):
    """Validate response for a detailed hash lookup that exists."""
    digest = "7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754"
    mock_lookup_exists(sha256_hash=digest)

    rsp = test_client.get(f"/details/sha256/{dquote(digest)}/")
    expected = {
        "api_error_message": "",
        "api_response": [
            {
                "classification": "TLP:CLEAR",
                "link": f"https://bazaar.abuse.ch/browse.php?search=sha256%3A{digest}",
                "count": 1,
                "malicious": True,
                "confirmed": False,
                "enrichment": [
                    {
                        "group": "summary",
                        "name": "vendor_detections",
                        "name_description": "",
                        "value": 4,
                        "value_description": "",
                    },
                    {
                        "group": "summary",
                        "name": "threat_name",
                        "name_description": "",
                        "value": "AZORult",
                        "value_description": "",
                    },
                    {
                        "group": "summary",
                        "name": "delivery_method",
                        "name_description": "",
                        "value": "email",
                        "value_description": "",
                    },
                    {
                        "group": "summary",
                        "name": "submission_comment",
                        "name_description": "comment by uploader",
                        "value": "Malspam distributing AZORult",
                        "value_description": "",
                    },
                    {
                        "group": "info",
                        "name": "filename",
                        "name_description": "",
                        "value": "file.exe",
                        "value_description": "",
                    },
                    {
                        "group": "file_origin",
                        "name": "reporter",
                        "name_description": "",
                        "value": "abuse_ch",
                        "value_description": "",
                    },
                    {
                        "group": "vendor_intelligence",
                        "name": "Spamhaus_HBL",
                        "name_description": "",
                        "value": "https://www.spamhaus.org/hbl/",
                        "value_description": "",
                    },
                ],
                "description": "4 security vendors flagged this file as malicious. The file has been identified as: AZORult",
            }
        ],
        "api_status_code": 200,
    }

    assert rsp.status_code == 200
    assert rsp.json == expected


def test_tag_details(test_client, mock_lookup_exists):
    """Validate respone for a detailed general tag lookup that exists."""
    # only hash lookups will have vendor_intel returned
    data = mock_lookup_exists(
        vendor_intel=None,
        additional_results={
            "sha256_hash": "a" * 64,
            "signature": "REDLINE",
            "intelligence": None,
            "tags": ["Malware"]
        },
    )

    rsp = test_client.get(f"/details/file.pe.imports.imphash/{dquote(data[0]['imphash'])}/")
    expected = {
        "api_error_message": "",
        "api_response": [
            {
                "classification": "TLP:CLEAR",
                "link": f"https://bazaar.abuse.ch/browse.php?search=imphash%3A{data[0]['imphash']}",
                "count": 2,
                "malicious": True,
                "confirmed": False,
                "description": "2 malicious files were found. They were identified as: AZORult, REDLINE",
                "enrichment": [
                    {
                        "group": "related_files",
                        "name": "7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754",
                        "name_description": "",
                        "value": "AZORult",
                        "value_description": "",
                    },
                    {
                        "group": "related_files",
                        "name": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                        "name_description": "",
                        "value": "REDLINE",
                        "value_description": "",
                    },
                    {
                        "group": "related_files",
                        "name": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                        "name_description": "",
                        "value": "Malware",
                        "value_description": "",
                    },
                ],
            }
        ],
        "api_status_code": 200,
    }

    assert rsp.status_code == 200
    assert rsp.json == expected
