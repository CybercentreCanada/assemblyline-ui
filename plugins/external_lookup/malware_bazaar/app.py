"""Lookup through Malware Bazaar.

"""
import json
import os

from urllib import parse as ul

import requests

from flask import Flask, Response, jsonify, make_response, request


app = Flask(__name__)


MAX_LIMIT = os.environ.get("MB_MAX_LIMIT", 100)  # Maximum number to return
MAX_TIMEOUT = float(os.environ.get("MAX_TIMEOUT", 3))
CLASSIFICATION = os.environ.get("CLASSIFICATION", "TLP:CLEAR")  # Classification of this service
API_URL = os.environ.get("API_URL", "https://mb-api.abuse.ch/api/v1")  # override in case of mirror
FRONTEND_URL = os.environ.get("FRONTEND_URL", "https://bazaar.abuse.ch/browse.php")  # override in case of mirror

# verify can be boolean or path to CA file
verify = str(os.environ.get("MB_VERIFY", "true")).lower()
if verify in ("true", "1"):
    verify = True
elif verify in ("false", "0"):
    verify = False
VERIFY = verify

# Mapping of AL tag names to external systems "tag" names
TAG_MAPPING = os.environ.get("TAG_MAPPING", {
    "file.pe.imports.imphash": "imphash",
    "md5": "md5",
    "sha1": "sha1",
    "sha256": "sha256",
    # "tlsh": "tlsh",  # TLSH searching for newer T1 prefixed hashes via API is broken in malware bazaar
})
if not isinstance(TAG_MAPPING, dict):
    TAG_MAPPING = json.loads(TAG_MAPPING)


def make_api_response(data, err: str = "", status_code: int = 200) -> Response:
    """Create a standard response for this API."""
    return make_response(
        jsonify({
            "api_response": data,
            "api_error_message": err,
            "api_status_code": status_code,
        }),
        status_code,
    )


@app.route("/tags/", methods=["GET"])
def get_tag_names() -> Response:
    """Return supported tag names."""
    return make_api_response({tname: CLASSIFICATION for tname in sorted(TAG_MAPPING)})


def lookup_tag(tag_name: str, tag: str, limit: int, timeout: float):
    """Lookup the tag in Malware bazaar.

    Tag values submitted must be URL encoded.

    Complete data from the lookup is returned unmodified.
    """
    search_key = tag_name
    if tag_name in ("md5", "sha1", "sha256"):
        search_key = "hash"
    if search_key == "hash" and len(tag) not in (32, 40, 64):
        return make_api_response(None, "Invalid hash provided. Require md5, sha1 or sha256", 422)

    session = requests.Session()
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }
    query = {
        "hash": "get_info",
        "imphash": "get_imphash",
        "tlsh": "get_tlsh",
    }[search_key]
    data = {
        "query": query,
        search_key: tag,
        "limit": limit,
    }

    try:
        rsp = session.post(f"{API_URL}/", data, headers=headers, verify=VERIFY, timeout=timeout)
    except requests.exceptions.ReadTimeout:
        return make_api_response("Malware Bazaar failed to respond in time", "ReadTimeout", 500)

    # MB should always return a 200, even on error.
    if rsp.status_code != 200:
        return make_api_response(rsp.text, "Unknown error submitting data to upstream.", rsp.status_code)

    rsp_json = rsp.json()
    query_status = rsp_json.get("query_status")
    if query_status in ("no_result", "hash_not_found"):
        return make_api_response(None, "No results.", 404)
    elif query_status != "ok":
        # any other error, just return a generic error code
        return make_api_response(None, query_status, 400)

    return rsp_json.get("data", [])


def _row(group, name, value, name_description="", value_description=""):
    """Return a formatted enrichment row."""
    return {
        "group": group,
        "name": name,
        "name_description": name_description,
        "value": value,
        "value_description": value_description,
    }


@app.route("/details/<tag_name>/<tag>/", methods=["GET"])
def tag_details(tag_name: str, tag: str) -> Response:
    """Get detailed lookup results from Malware Bazaar

    Variables:
    tag_name => Tag to look up in the external system.
    tag => Tag value to lookup. *Must be double URL encoded.*

    Query Params:
    max_timeout => Maximum execution time for the call in seconds
    limit       => Maximum number of items to return
    nodata      => If specified, do not return the enrichment data

    Returns:
    # List of:
    [
        {
            "description": "",                     # Description of the findings
            "malicious": <bool>,                   # Is the file found malicious or not
            "confirmed": <bool>,                   # Is the maliciousness attribution confirmed or not
            "classification": <access control>,    # [Optional] Classification of the returned data
            "link": <url to search results in external system>,
            "count": <count of results from the external system>,
            "enrichment": [
                {"group": <group>,
                 "name": <name>, "name_description": <description>,
                 "value": <value>, "value_description": <description>,
                },
                ...,
            ]   # [Optional] ordered groupings of additional metadata
        },
        ...,
    ]
    """
    tag = ul.unquote(ul.unquote(tag))
    # Invalid tags must either be ignored, or return a 422
    tn = TAG_MAPPING.get(tag_name)
    if tn is None:
        return make_api_response(
            None,
            f"Tag name `{tag_name}` is invalid. Valid tags are: {', '.join(TAG_MAPPING.keys())}",
            422,
        )
    enrich = not request.args.get("nodata", "false").lower() in ("true", "1")

    limit = int(request.args.get("limit", "100"))
    if limit > int(MAX_LIMIT):
        limit = int(MAX_LIMIT)
    max_timeout = request.args.get("max_timeout", MAX_TIMEOUT)
    # noinspection PyBroadException
    try:
        max_timeout = float(max_timeout)
    except Exception:
        max_timeout = 3.0

    data = lookup_tag(tag_name=tn, tag=tag, limit=limit, timeout=max_timeout)
    if isinstance(data, Response):
        return data

    r = {
        "classification": CLASSIFICATION,
        "link": f"{FRONTEND_URL}?search={tn}%3A{tag}",
        "count": len(data),
        "confirmed": False,  # malware bazaar does not offer a confirmed property
    }

    # for hashes, we expect a single result back and can provide more details through enrichment
    if tn in ("md5", "sha1", "sha256"):
        vendors = 0
        malicious = False
        entry = data[0]
        if (threat := entry["signature"]) or entry["intelligence"].get("clamav", []):
            malicious = True
            vendors += 1
        # set malicious if any vendor flags as malicious.
        for intel in entry.get("vendor_intel", {}).values():
            # vendor_intel is not consistent and contains some entries that are dicts and others that are lists
            if not isinstance(intel, list):
                intel = [intel]
            for i in intel:
                if isinstance(i, dict):
                    # this is a very dirty check...
                    m = i.get("detection") or i.get("verdict") or i.get("status")
                    if m and "malicious" in m.lower():
                        malicious = True
                        vendors += 1
                        break
        desc = f"{vendors} security vendors flagged this file as malicious."
        if threat:
            desc += f" The file has been identified as: {threat}"

        r["malicious"] = malicious
        r["description"] = desc

        if enrich:
            # define order of groups
            groups = {
                "summary": [_row("summary", "vendor_detections", vendors)],
                "yara": [],
                "info": [],
                "file_origin": [],
                "vendor_intelligence": [],
            }

            # summary
            if sig := entry["signature"]:
                groups["summary"].append(_row("summary", "threat_name", sig))
            if dm := entry["delivery_method"]:
                groups["summary"].append(_row("summary", "delivery_method", dm))
            if pw := entry["archive_pw"]:
                groups["summary"].append(_row("summary", "archive_pw", pw))
            if c := entry["comment"]:
                groups["summary"].append(
                    _row("summary", "submission_comment", c, name_description="comment by uploader")
                )

            # Origin
            if up := entry["intelligence"].get("uploads"):
                groups["file_origin"].append(_row("file_origin", "#_uploads", up))
            if dn := entry["intelligence"].get("downloads"):
                groups["file_origin"].append(_row("file_origin", "#_downloads", dn))
            if origin := entry["origin_country"]:
                groups["file_origin"].append(_row("file_origin", "origin_country", origin))
            if reporter := entry["reporter"]:
                groups["file_origin"].append(_row("file_origin", "reporter", reporter))

            # General Info
            for t in (entry["tags"] or []):
                groups["info"].append(_row("info", "tag", t))
            if fn := entry["file_name"]:
                groups["info"].append(_row("info", "filename", fn))
            for fi in (entry["file_information"] or {}):
                if (ctx := fi.get("context")) and (v := fi.get("value")):
                    groups["info"].append(_row("info", ctx, v))

            # Yara
            for yr in (entry["yara_rules"] or []):
                if (name := yr.get("rule_name")) and (author := yr.get("author")):
                    groups["yara"].append(_row("yara_rules", author, name, value_description=yr.get("description", "")))

            # vendor results
            for vendor, intel in entry.get("vendor_intel", {}).items():
                # vendor_intel is not consistent and contains some entries that are dicts and others that are lists
                if not isinstance(intel, list):
                    intel = [intel]
                seen = []  # some vendors return the same link multiple times
                for i in intel:
                    if isinstance(i, dict):
                        m = i.get("detection") or i.get("verdict") or i.get("status")
                        if m and "malicious" in m.lower():
                            for k, v in i.items():
                                # there is no standard key for the result link
                                if "url" in k or "link" in k:
                                    if v and v not in seen:
                                        groups["vendor_intelligence"].append(_row("vendor_intelligence", vendor, v))
                                        seen.append(v)

            enrichment = []
            for rows in groups.values():
                enrichment.extend(rows)
            r["enrichment"] = enrichment

    # for everything else, we may get results for more than one entity
    else:
        threats = []
        info = {}
        mal_count = 0
        for entry in data:
            if (threat := entry["signature"]) or entry["intelligence"].get("clamav", []):
                mal_count += 1
                if threat and threat not in threats:
                    threats.append(threat)
                if enrich:
                    h = entry["sha256_hash"]
                    # even if there are no tags, ensure hash is recorded
                    info.setdefault(h, [])
                    if threat and threat not in info[h]:
                        info[h].append(threat)
                    for t in (entry.get("tags") or []):
                        if t not in info[h]:
                            info[h].append(t)

        desc = f"{mal_count} malicious files were found."
        if threats:
            desc += f" They were identified as: {', '.join(threats)}"

        r["malicious"] = mal_count > 0
        r["description"] = desc

        if enrich:
            enrichment = []
            tags = []
            for h, tags in info.items():
                if not tags:
                    enrichment.append(_row("related_files", h, ""))
                for tag in tags:
                    enrichment.append(_row("related_files", h, tag))
            r["enrichment"] = enrichment

    return make_api_response([r])


def main():
    app.run(host="0.0.0.0", port=8000, debug=False)


if __name__ == "__main__":
    main()
